/* AUTOGENERATED FILE - DO NOT EDIT CONTENTS */

export const projectId = "mfnwotokumvnszljeuom"
export const publicAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1mbndvdG9rdW12bnN6bGpldW9tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI0Mzc2MzksImV4cCI6MjA2ODAxMzYzOX0.pLHqw9ktgzbm2jyKvdvV2Zu4aNdN5MhAPXEiCClUr4Q"

// App configuration
export const appConfig = {
  name: 'SupaApp',
  version: '2.0.0',
  mode: 'live',
  features: {
    realtime: true,
    gamification: true,
    stories: true,
    liveEvents: true,
    hapticFeedback: true
  }
}

// API Endpoints configuration
export const apiEndpoints = {
  base: `https://${projectId}.supabase.co/functions/v1/make-server-0e8b25fb`,
  health: '/health',
  auth: {
    signup: '/auth/signup',
    signin: '/auth/signin',
    signout: '/auth/signout',
    user: '/auth/user'
  },
  chats: {
    list: '/chats',
    messages: '/messages',
    send: '/messages/send'
  },
  communities: {
    list: '/communities',
    join: '/communities/join',
    posts: '/communities/posts'
  },
  gamification: {
    profile: '/gamification/profile',
    leaderboard: '/gamification/leaderboard',
    achievements: '/gamification/achievements'
  },
  marketplace: {
    products: '/marketplace/products',
    categories: '/marketplace/categories'
  },
  learning: {
    courses: '/learning/courses',
    progress: '/learning/progress'
  },
  stories: {
    list: '/stories',
    create: '/stories/create',
    view: '/stories/view'
  },
  live: {
    events: '/live/events',
    rooms: '/live/rooms',
    join: '/live/join'
  }
}

// Build endpoint URL utility
export const buildEndpoint = (path: string): string => {
  const baseUrl = apiEndpoints.base
  const cleanPath = path.startsWith('/') ? path : `/${path}`
  return `${baseUrl}${cleanPath}`
}

// Authenticated API call utility
export const authenticatedApiCall = async (
  endpoint: string,
  options: RequestInit = {},
  accessToken?: string
): Promise<Response> => {
  try {
    const url = endpoint.startsWith('http') ? endpoint : buildEndpoint(endpoint)
    
    // Get access token from auth if not provided
    let authToken = accessToken
    if (!authToken) {
      try {
        const { auth } = await import('./client')
        const { data: { session } } = await auth.getSession()
        authToken = session?.access_token
      } catch (error) {
        console.warn('‚ö†Ô∏è Could not get auth session:', error)
      }
    }

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...options.headers as Record<string, string>
    }

    // Add authentication header
    if (authToken) {
      headers['Authorization'] = `Bearer ${authToken}`
    } else {
      // Fallback to public anon key
      headers['Authorization'] = `Bearer ${publicAnonKey}`
    }

    const requestOptions: RequestInit = {
      ...options,
      headers
    }

    console.log(`üåê API Call: ${options.method || 'GET'} ${url}`)
    
    const response = await fetch(url, requestOptions)
    
    if (!response.ok) {
      console.error(`‚ùå API Error: ${response.status} ${response.statusText}`)
      throw new Error(`API request failed: ${response.status} ${response.statusText}`)
    }
    
    return response
  } catch (error: any) {
    console.error('‚ùå Authenticated API call failed:', error)
    throw error
  }
}

// Health check function
export const checkBackendHealth = async (): Promise<{ healthy: boolean; message: string }> => {
  try {
    // Try multiple endpoints with increasing timeout
    const endpoints = [
      `https://${projectId}.supabase.co/functions/v1/make-server-0e8b25fb/health`,
      `https://${projectId}.supabase.co/rest/v1/`,
      `https://${projectId}.supabase.co/auth/v1/health`
    ]

    let lastError: any = null

    for (const endpoint of endpoints) {
      try {
        console.log(`üîç Checking endpoint: ${endpoint}`)
        
        const controller = new AbortController()
        const timeoutId = setTimeout(() => controller.abort(), 8000)
        
        const response = await fetch(endpoint, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${publicAnonKey}`,
            'apikey': publicAnonKey,
            'Content-Type': 'application/json'
          },
          signal: controller.signal
        })
        
        clearTimeout(timeoutId)
        
        if (response.ok || response.status === 404) {
          console.log(`‚úÖ Endpoint ${endpoint} responded with status: ${response.status}`)
          return {
            healthy: true,
            message: 'Connected to Supabase backend'
          }
        } else {
          console.warn(`‚ö†Ô∏è Endpoint ${endpoint} returned status: ${response.status}`)
          lastError = new Error(`HTTP ${response.status}`)
        }
      } catch (error: any) {
        console.warn(`‚ö†Ô∏è Endpoint ${endpoint} failed:`, error.message)
        lastError = error
        continue // Try next endpoint
      }
    }

    return {
      healthy: false,
      message: `All endpoints failed. Last error: ${lastError?.message || 'Unknown error'}`
    }
  } catch (error: any) {
    console.error('‚ùå Health check error:', error)
    return {
      healthy: false,
      message: `Health check failed: ${error.message}`
    }
  }
}

// Network connectivity check
export const checkNetworkConnectivity = async (): Promise<boolean> => {
  try {
    // Check if navigator.onLine is available (browser support)
    if (typeof navigator !== 'undefined' && 'onLine' in navigator) {
      if (!navigator.onLine) {
        console.log('üåê Browser reports offline')
        return false
      }
    }

    // Try to fetch a reliable endpoint
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 5000)
    
    try {
      await fetch('https://www.google.com/favicon.ico', {
        method: 'HEAD',
        mode: 'no-cors',
        signal: controller.signal
      })
      clearTimeout(timeoutId)
      console.log('üåê Network connectivity confirmed')
      return true
    } catch (error) {
      clearTimeout(timeoutId)
      console.log('üåê Network connectivity check failed, trying alternative...')
      
      // Fallback: try a different endpoint
      const fallbackController = new AbortController()
      const fallbackTimeoutId = setTimeout(() => fallbackController.abort(), 3000)
      
      try {
        await fetch('https://jsonplaceholder.typicode.com/posts/1', {
          method: 'HEAD',
          signal: fallbackController.signal
        })
        clearTimeout(fallbackTimeoutId)
        console.log('üåê Network connectivity confirmed via fallback')
        return true
      } catch (fallbackError) {
        clearTimeout(fallbackTimeoutId)
        console.log('üåê No network connectivity detected')
        return false
      }
    }
  } catch (error: any) {
    console.error('‚ùå Network check error:', error)
    return false
  }
}

// Check if connected to real backend
export const isConnectedToRealBackend = (): boolean => {
  const hasProjectId = Boolean(projectId && projectId.length > 0)
  const hasAnonKey = Boolean(publicAnonKey && publicAnonKey.length > 10)
  const isRealProject = projectId !== 'your-project-id' && projectId !== 'demo'
  
  console.log('üîç Backend connection check:', {
    hasProjectId,
    hasAnonKey,
    isRealProject,
    projectId: projectId.substring(0, 8) + '...'
  })
  
  return hasProjectId && hasAnonKey && isRealProject
}

// Validation utilities
export const validators = {
  email: (email: string): boolean => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  },
  
  password: (password: string): { isValid: boolean; errors: string[] } => {
    const errors: string[] = []
    
    if (password.length < 8) {
      errors.push('Password must be at least 8 characters long')
    }
    
    if (!/(?=.*[a-z])/.test(password)) {
      errors.push('Password must contain at least one lowercase letter')
    }
    
    if (!/(?=.*[A-Z])/.test(password)) {
      errors.push('Password must contain at least one uppercase letter')
    }
    
    if (!/(?=.*\d)/.test(password)) {
      errors.push('Password must contain at least one number')
    }
    
    return {
      isValid: errors.length === 0,
      errors
    }
  },
  
  username: (username: string): boolean => {
    // Username should be 3-20 characters, alphanumeric with underscores/hyphens
    const usernameRegex = /^[a-zA-Z0-9_-]{3,20}$/
    return usernameRegex.test(username)
  },
  
  displayName: (name: string): boolean => {
    // Display name should be 1-50 characters, allow spaces and basic punctuation
    return name.length >= 1 && name.length <= 50 && /^[a-zA-Z0-9\s\-_.]+$/.test(name)
  }
}

// Export environment info for debugging
export const getEnvironmentInfo = () => ({
  projectId: projectId.substring(0, 8) + '...',
  hasValidConfig: isConnectedToRealBackend(),
  userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'Unknown',
  timestamp: new Date().toISOString(),
  mode: appConfig.mode
})

// Development mode check
export const isDevelopment = (): boolean => {
  // Check for development indicators
  const hostname = typeof window !== 'undefined' ? window.location?.hostname : 'localhost'
  const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1' || hostname.includes('.local')
  const hasDevPort = typeof window !== 'undefined' && window.location?.port && ['3000', '5173', '8080'].includes(window.location.port)
  
  // Check environment variables if available
  const nodeEnv = typeof process !== 'undefined' ? process.env?.NODE_ENV : undefined
  const isDev = nodeEnv === 'development'
  
  return isDev || isLocalhost || hasDevPort || false
}

// Helper function to get base URL for different services
export const getServiceUrl = (service: 'functions' | 'rest' | 'auth' | 'storage' = 'functions') => {
  const baseUrl = `https://${projectId}.supabase.co`
  
  switch (service) {
    case 'functions':
      return `${baseUrl}/functions/v1`
    case 'rest':
      return `${baseUrl}/rest/v1`
    case 'auth':
      return `${baseUrl}/auth/v1`
    case 'storage':
      return `${baseUrl}/storage/v1`
    default:
      return baseUrl
  }
}

// Common API response handler
export const handleApiResponse = async (response: Response) => {
  if (!response.ok) {
    const errorText = await response.text()
    throw new Error(`API Error ${response.status}: ${errorText}`)
  }
  
  try {
    return await response.json()
  } catch (error) {
    // Return empty object if response is not JSON
    return {}
  }
}